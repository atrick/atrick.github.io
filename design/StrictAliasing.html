---
layout: default
title: StrictAliasing.html
categories: design
date: 2016-04-09
---
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Swift Strict Aliasing &mdash; Swift 3.0 documentation</title>
    
    <link rel="stylesheet" href="_static/swift.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '3.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="top" title="Swift 3.0 documentation" href="contents.html" /> 
  </head>
  <body role="document">
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>Swift 3.0 documentation</span></a></h1>
        <h2 class="heading"><span>Swift Strict Aliasing</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        <a class="uplink" href="contents.html">Contents</a>
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="swift-strict-aliasing">
<h1>Swift Strict Aliasing<a class="headerlink" href="#swift-strict-aliasing" title="Permalink to this headline">¶</a></h1>
<p>This is work-in-progress, not an official language specification.</p>
<div class="section" id="definitions">
<h2>Definitions<a class="headerlink" href="#definitions" title="Permalink to this headline">¶</a></h2>
<p>Swift follows strict aliasing rules. The language generally prevents
violation of these rules; however, code that uses unsafe APIs or
imported types can circumvent the language&#8217;s natural type
safety. Consider the following example of <em>type punning</em> using the
UnsafePointer type:</p>
<div class="highlight-swift"><div class="highlight"><pre><span class="kd">let </span><span class="nv">ptrT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">allocatingCapacity</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="c1">// Store T at this address.</span>
<span class="n">ptrT</span><span class="p">.</span><span class="n">pointee</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">T</span><span class="p">()</span>
<span class="c1">// Load U at this address</span>
<span class="kd">let </span><span class="nv">u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UnsafePointer</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ptrT</span><span class="p">).</span><span class="n">pointee</span>
</pre></div>
</div>
<p>The program exhibits undefined behavior unless &#8216;T&#8217; and &#8216;U&#8217; are
related types <a class="footnote-reference" href="#relatedtypes" id="id1">[1]</a> and the loaded type &#8216;U&#8217; is layout
compatible with the stored type &#8216;T&#8217; <a class="footnote-reference" href="#layoutcompatible" id="id2">[2]</a>.</p>
<table class="docutils footnote" frame="void" id="relatedtypes" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id4">2</a>)</em> <strong>related types</strong>: Two types are related if: (a) the types are
identical or aliases of each other; or (b) one type may be a
tuple, enum, or struct that contains the other type as part of
its own storage; or (c) one type may be an existential that the
other type conforms to; or (d) both types may be classes and
one may be a superclass of the other.</td></tr>
</tbody>
</table>
<p>Note that class types are not related to their subobjects. Thus a
stored property must always be accessed through related classes types.</p>
<dl class="docutils">
<dt><strong>Related Type Rule</strong>: Any two accessess at the same memory location,</dt>
<dd>in which at least one access is a store, must have related
types. This applies to all memory accesses that exist statically
within the same Swift program.</dd>
</dl>
<table class="docutils footnote" frame="void" id="layoutcompatible" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td><em>(<a class="fn-backref" href="#id2">1</a>, <a class="fn-backref" href="#id3">2</a>)</em> <dl class="docutils">
<dt><strong>layout compatible types</strong>: Two types are layout compatible if</dt>
<dd>their in-memory representation has the same size and alignment
or they have the same number of mutually layout compatible
elements. Layout compatibility guarantees may be expanded over
time; however, some &#8220;obvious&#8221; examples of layout compatible
types are:</dd>
</dl>
<ul class="last simple">
<li>integers of the same multiple-of-8 size in bits</li>
<li>floating point types of the same size</li>
<li>class types and AnyObject existentials</li>
<li>pointer types (e.g. OpaquePointer, UnsafePointer)</li>
<li>thin function, C function, and block function types</li>
<li>imported C types that have the same layout in C</li>
<li>nonresilient structs with one stored property and their stored
property type</li>
<li>nonresilient enums with one case and their payload type</li>
<li>nonresilient enums with one payload case (and zero or more
no-payload cases) have a layout compatible payload type, but <em>not</em>
mutually.</li>
<li>homogeneous tuples, fixed-sized array storage of the same element
type, and homogeneous nonresilient structs in which the element
type has no spare bits (structs may be bit packed).</li>
</ul>
</td></tr>
</tbody>
</table>
<p><strong>Layout Rules</strong>:</p>
<ol class="arabic simple">
<li>Loads must be layout compatible with all stores to the same address.</li>
<li>Stores to the same address must be commutatively layout compatible.</li>
</ol>
<p>Layout rules apply to all dynamic memory accesses that occur during program execution.</p>
</div>
<div class="section" id="exempt-types">
<h2>Exempt Types<a class="headerlink" href="#exempt-types" title="Permalink to this headline">¶</a></h2>
<p>Swift does not currently specify any types that are exempt from strict
aliasing. In the future, it may be useful to declare certain types as
exempt&#8211;for example, that &#8216;UInt8&#8217; aliases with all other types. Since
this is not currently the case, all accesses to a memory location must
have a related type.</p>
</div>
<div class="section" id="legally-circumventing-strict-aliasing">
<h2>Legally Circumventing Strict Aliasing<a class="headerlink" href="#legally-circumventing-strict-aliasing" title="Permalink to this headline">¶</a></h2>
<p>Accessing unrelated layout compatible types requires special
consideration. For example, Int32 and UInt32 are &#8220;obviously&#8221; layout
compatible; however, simply storing to a location via
UnsafeMutablePointer&lt;Int32&gt; and loading from the same location as
UnsafePointer&lt;UInt32&gt; is undefined.</p>
<p>Reinterpreting a value&#8217;s bits should be done using unsafeBitCast to
avoid type punning. For example, the above conversion can be performed
legally as:</p>
<div class="highlight-swift"><div class="highlight"><pre><span class="kd">let </span><span class="nv">ptrI32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="n">Int32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">allocatingCapacity</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="n">ptrI32</span><span class="p">.</span><span class="n">pointee</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">Int32</span><span class="p">()</span>
<span class="kd">let </span><span class="nv">u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">unsafeBitCast</span><span class="p">(</span><span class="n">ptrI32</span><span class="p">.</span><span class="n">pointee</span><span class="p">,</span><span class="w"> </span><span class="n">to</span><span class="p">:</span><span class="w"> </span><span class="no">UInt32</span><span class="p">.</span><span class="n">self</span><span class="p">)</span>
</pre></div>
</div>
<p>In the future, an API will likely exist to allow legal type
punning. This could be useful for external APIs that require pointer
arguments and for manual memory layout. Loads and stores of type
punned memory would still need to follow the layout rules <a class="footnote-reference" href="#layoutcompatible" id="id3">[2]</a> for loads
and stores, but would be exempt from the related type rule <a class="footnote-reference" href="#relatedtypes" id="id4">[1]</a>. Such an
API, for example, would allow accessing same address as both Int32 and
UInt32.</p>
</div>
<div class="section" id="casting-pointers">
<h2>Casting Pointers<a class="headerlink" href="#casting-pointers" title="Permalink to this headline">¶</a></h2>
<p>unsafeBitCast should generally be avoided on pointer types, and should
almost exclusively be avoided on class types. unsafeBitCast is valid for
pointer to integer conversions. It is also used in the standard
library for some internal pointer types that are not
dereferenceable. As with any conversion to and from opaque pointers,
this presents an opportunity for type punning, thus must be used
with extreme caution to avoid undefined behavior.</p>
<p>unsafeBitCast is even more problematic for class types. First, layout
needs to be considered when Optional or existential class types are
involved. Note that the internal _unsafeReferenceCast API is preferred
in those cases, because it always handles conversions to and from
optionals and existentials correctly.</p>
<p>Furthermore, unsafeBitCast of class types may introduce undefined
behavior at the point of access. Normal class casts and class
existential casts rely on the dynamic type to be a subclass of or
conform to the static type at the point of the cast. An unsafeBitCast
will succeed...
Consider this example:</p>
<div class="highlight-swift"><div class="highlight"><pre><span class="n">paste</span><span class="w"> </span><span class="n">unsafeBitCastAlias</span><span class="p">.</span><span class="n">swift</span>
</pre></div>
</div>
<p>This code exhibits undefined behavior for two reasons. First, it
violates strict aliasing rules because, after function inlining, the
same stored proper may be accessed via unrelated class types. Second,
there is no guarantee of layout among unrelated classes even if they
are nonresilient.</p>
<p>&#8212;
Consequently, capturing a pointer to a stored property is illegal.</p>
<p>Example...</p>
<p>&#8212;</p>
<p>This limitation is not related the compiler&#8217;s requirement for
StrictAliasing, which is only concerned with <em>multiple</em> accesses to a
location of unrelated <em>static</em> type. Rather, a single access or cast
to a class whose dynamic type is unrelated to its static type results
in undefined behavior, but only if that access occurs <em>dynamically</em>
during execution. For example the following:</p>
<div class="highlight-swift"><div class="highlight"><pre>public protocol SomeClass : class {
  func getVal() -&gt; Int
}
class ActualClass {
  var i: Int
  init(i: Int) { self.i = i }
}

public func foo&lt;T : SomeClass&gt;(obj: T, isActualClass: Bool) -&gt; Int {
  // This unsafe cast violates the type system because it&#39;s operating on class types.
  let actualRef = unsafeBitCast(obj, to: ActualClass.self)
  if (isActualClass) {
    // The unsafe cast is only valid under this condition.
    return actualRef.i
  }
  return obj.getVal()
}
</pre></div>
</div>
<p>The following code is both legal and more explicit:</p>
<div class="highlight-swift"><div class="highlight"><pre><span class="n">public</span><span class="w"> </span><span class="kd">func </span><span class="nf">foo</span><span class="p">&lt;</span><span class="no">T</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">SomeClass</span><span class="p">&gt;(</span><span class="n">obj</span><span class="p">:</span><span class="w"> </span><span class="n">T</span><span class="p">, </span><span class="n">isActualClass</span><span class="p">:</span><span class="w"> </span><span class="n">Bool</span><span class="p">)</span><span class="o"> -&gt; </span><span class="no">Int</span><span class="p"> {</span>
<span class="w">  </span><span class="kr">if </span><span class="p">(</span><span class="n">isActualClass</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Now we know that the unsafeReferenceCast is type safe.</span>
<span class="w">    </span><span class="kd">let </span><span class="nv">actualRef</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">unsafeReferenceCast</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span><span class="w"> </span><span class="n">to</span><span class="p">:</span><span class="w"> </span><span class="no">ActualClass</span><span class="p">.</span><span class="n">self</span><span class="p">)</span>
<span class="w">    </span><span class="kr">return</span><span class="w"> </span><span class="n">actualRef</span><span class="p">.</span><span class="n">i</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="kr">return</span><span class="w"> </span><span class="n">obj</span><span class="p">.</span><span class="n">getVal</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        <a class="uplink" href="contents.html">Contents</a>
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &copy; Copyright 2016, Apple Inc.
      Last updated on 2016-04-06.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>