---
layout: default
title: StrictAliasing.html
categories: design
date: 2016-04-05
---
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Swift Strict Aliasing &mdash; Swift 3.0 documentation</title>
    
    <link rel="stylesheet" href="_static/swift.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '3.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="top" title="Swift 3.0 documentation" href="contents.html" /> 
  </head>
  <body role="document">
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>Swift 3.0 documentation</span></a></h1>
        <h2 class="heading"><span>Swift Strict Aliasing</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        <a class="uplink" href="contents.html">Contents</a>
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="swift-strict-aliasing">
<h1>Swift Strict Aliasing<a class="headerlink" href="#swift-strict-aliasing" title="Permalink to this headline">¶</a></h1>
<div class="section" id="specification">
<h2>Specification<a class="headerlink" href="#specification" title="Permalink to this headline">¶</a></h2>
<p>Swift follows strict aliasing rules. The language generally prevents
violation of these rules; however, code that uses unsafe APIs or
imports types can circumvent the language&#8217;s natural type
safety. Consider the following example of <em>type punning</em> using the
UnsafePointer type:</p>
<div class="highlight-swift"><div class="highlight"><pre><span class="kd">let </span><span class="nv">ptrToT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">allocatingCapacity</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="c1">// Store T at this address.</span>
<span class="n">uptr</span><span class="p">.</span><span class="n">pointee</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">T</span><span class="p">()</span>
<span class="c1">// Load U at this address</span>
<span class="kd">let </span><span class="nv">u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UnsafePointer</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ptrToT</span><span class="p">).</span><span class="n">pointee</span>
</pre></div>
</div>
<p>The program exhibits undefined behavior unless &#8216;T&#8217; and &#8216;U&#8217; are
<strong>related types</strong> <a class="footnote-reference" href="#id3" id="id1">[1]</a> and the loaded type &#8216;U&#8217; is <strong>layout
compatible</strong> with the stored type &#8216;T&#8217; <a class="footnote-reference" href="#id4" id="id2">[2]</a>. This applies to any two
accessess to the same memory location within the same Swift
program. All accesses to a location must have a related type, all
loads must be layout compatible with stores to the same address, and
all stores to the same address must be commutatively layout
compatible.</p>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><strong>related types</strong>: Two value types are related if: (a) the
types are identical or aliases of each other; or (b) one type
may be a tuple, enum, or struct that contains the other type as
part of its own storage; or (c) one type may be an existential
that the other type conforms to; or (d) both types are classes
and one is a superclass of the other.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td><dl class="first docutils">
<dt><strong>layout compatible types</strong>: Two types are layout compatible if</dt>
<dd>their in-memory representation has the same size and alignment
and the same number of mutually layout compatible
elements. Some &#8220;obvious&#8221; examples of layout compatible types
are:</dd>
</dl>
<ul class="last simple">
<li>integers of the same multiple-of-8 size in bits</li>
<li>floating point types of the same size</li>
<li>class types and AnyObject existentials</li>
<li>pointer types (e.g. OpaquePointer, UnsafePointer)</li>
<li>thin function, C function, and block function types</li>
<li>imported C types that have the same layout in C</li>
<li>nonresilient structs with one stored property and their stored property
type</li>
<li>nonresilient enums with one case and their payload type</li>
<li>nonresilient enums with one payload case (and zero or more
no-payload cases) have a layout compatible payload type, but <em>not</em>
commutatively.</li>
<li>homogeneous tuples, fixed-sized array storage of the same element type,
and homogeneous nonresilient structs in which the element type has no spare bits
(structs may be bit packed).</li>
</ul>
</td></tr>
</tbody>
</table>
<p>Note that many types are layout compatible but not related. For example, Int32 and UInt32 are &#8220;obviously&#8221; layout compatible</p>
<p>If a loaded value must be converted</p>
</div>
<div class="section" id="legally-circumventing-strict-aliasing">
<h2>Legally Circumventing Strict Aliasing<a class="headerlink" href="#legally-circumventing-strict-aliasing" title="Permalink to this headline">¶</a></h2>
<p>Reinterpreting a value should be done using unsafeBitCast should generally not be used to reinterpret pointer types. If it is used on pointers then it is subject to the same rules as UnsafePointer conversion for avoiding undefined behavior.</p>
<p>Example</p>
<p>In the future, an API will likely exist to allow legal type punning. Loads and stores of type punned memory would still need to follow the rules for layout compatible loads and stores, but the types would not need to be related.</p>
</div>
<div class="section" id="exempt-types">
<h2>Exempt Types<a class="headerlink" href="#exempt-types" title="Permalink to this headline">¶</a></h2>
<p>Swift does not currently specify any types that are exempt from strict
aliasing. In the future, it may be useful to declare certain types as
exempt&#8211;for example, that &#8216;UInt8&#8217; aliases with all other
types. However, this is not currently true; therefore all accesses to
a memory location must have a related type.</p>
</div>
</div>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        <a class="uplink" href="contents.html">Contents</a>
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &copy; Copyright 2016, Apple Inc.
      Last updated on 2016-04-05.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>